BiocManager::install("Biostrings")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("Biostrings")
library("readBStringSet")
library("igraph")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("Biostrings", force = TRUE)
library("readBStringSet")
BiocManager::install("Biostrings", force = TRUE)
library("readBStringSet")
BiocManager::install("Biostrings", force = TRUE)
library("readBStringSet")
library("Biostrings")
library("igraph")
##### Parameters
seq_name <- "teste.fasta"
seq <- readBStringSet(mRNA)
seq <- readBStringSet(seq_name)
##### createNet funcion
createNet <- function(word, step, sequence){
aux<-""
index<-1
position<-0
cont<-length(sequence)
comma<-0
x<-0
k<-1
vector<-c()
while((index-1+(word*2))<cont){
while(x<word){
aux<-paste(aux,sequence[index],sep="");
x<-x+1;
index<-index+1;
}
vector<-c(vector,aux)
aux<-""
x<-0;
while(x<word){
aux<-paste(aux,sequence[index],sep="");
x<-x+1;
index<-index+1;
}
vector<-c(vector,aux)
aux<-""
x<-0;
position<-position+step;
index<-position+1;
}
net<-graph <- graph(edges=vector,directed=FALSE)
matriz<-as_adjacency_matrix(net)
net<-graph_from_adjacency_matrix(matriz, mode="undirected", weighted = TRUE)
return(net)
}
##### GET NET FROM SEQ
for(x in seq_along(seq)){
if(missing(load)){
message(x)
}
sequence<-strsplit(toString(seq[x]),split='')
sequence<-sequence[[1]]
net<-createNet(word, step, sequence)
}
##### GET NET FROM SEQ
for(x in seq_along(seq)){
sequence<-strsplit(toString(seq[x]),split='')
sequence<-sequence[[1]]
net<-createNet(word, step, sequence)
}
word <- 3
step <- 1
seq <- readBStringSet(seq_name)
##### createNet funcion
createNet <- function(word, step, sequence){
aux<-""
index<-1
position<-0
cont<-length(sequence)
comma<-0
x<-0
k<-1
vector<-c()
while((index-1+(word*2))<cont){
while(x<word){
aux<-paste(aux,sequence[index],sep="");
x<-x+1;
index<-index+1;
}
vector<-c(vector,aux)
aux<-""
x<-0;
while(x<word){
aux<-paste(aux,sequence[index],sep="");
x<-x+1;
index<-index+1;
}
vector<-c(vector,aux)
aux<-""
x<-0;
position<-position+step;
index<-position+1;
}
net<-graph <- graph(edges=vector,directed=FALSE)
matriz<-as_adjacency_matrix(net)
net<-graph_from_adjacency_matrix(matriz, mode="undirected", weighted = TRUE)
return(net)
}
##### GET NET FROM SEQ
for(x in seq_along(seq)){
sequence<-strsplit(toString(seq[x]),split='')
sequence<-sequence[[1]]
net<-createNet(word, step, sequence)
}
##### createNet funcion
createNet <- function(word, step, sequence){
aux<-""
index<-1
position<-0
cont<-length(sequence)
comma<-0
x<-0
k<-1
vector<-c()
while((index-1+(word*2))<cont){
while(x<word){
aux<-paste(aux,sequence[index],sep="");
x<-x+1;
index<-index+1;
}
vector<-c(vector,aux)
aux<-""
x<-0;
while(x<word){
aux<-paste(aux,sequence[index],sep="");
x<-x+1;
index<-index+1;
}
vector<-c(vector,aux)
aux<-""
x<-0;
position<-position+step;
index<-position+1;
}
net<-graph <- graph(edges=vector,directed=FALSE)
#matriz<-as_adjacency_matrix(net)
#net<-graph_from_adjacency_matrix(matriz, mode="undirected", weighted = TRUE)
return(net)
}
##### GET NET FROM SEQ
for(x in seq_along(seq)){
sequence<-strsplit(toString(seq[x]),split='')
sequence<-sequence[[1]]
net<-createNet(word, step, sequence)
}
print(net)
install.packages("igraph")
install.packages("igraph")
library("Biostrings")
library("igraph")
##### Parameters
seq_name <- "teste.fasta"
word <- 3
step <- 1
seq <- readBStringSet(seq_name)
##### createNet funcion
createNet <- function(word, step, sequence){
aux<-""
index<-1
position<-0
cont<-length(sequence)
comma<-0
x<-0
k<-1
vector<-c()
while((index-1+(word*2))<cont){
while(x<word){
aux<-paste(aux,sequence[index],sep="");
x<-x+1;
index<-index+1;
}
vector<-c(vector,aux)
aux<-""
x<-0;
while(x<word){
aux<-paste(aux,sequence[index],sep="");
x<-x+1;
index<-index+1;
}
vector<-c(vector,aux)
aux<-""
x<-0;
position<-position+step;
index<-position+1;
}
net<-graph <- graph(edges=vector,directed=FALSE)
matriz<-as_adjacency_matrix(net)
net<-graph_from_adjacency_matrix(matriz, mode="undirected", weighted = TRUE)
return(net)
}
##### GET NET FROM SEQ
for(x in seq_along(seq)){
sequence<-strsplit(toString(seq[x]),split='')
sequence<-sequence[[1]]
net<-createNet(word, step, sequence)
}
print(net)
require(stats)
#Domain setup
T <- 5
dt <- 0.01 #s
n <- T/dt
F <-1/dt
df <- 1/T
freq<-5 #Hz
t <- seq(0,T,by=dt) #also try ts function
#CREATE OUR TIME SERIES DATA
y <- 10*sin(2*pi*freq*t) +4* sin(2*pi*20*t)
#CREATE OUR FREQUENCY ARRAY
f <- 1:length(t)/T
#FOURIER TRANSFORM WORK
Y <- fft(y)
mag <- sqrt(Re(Y)^2+Im(Y)^2)*2/n
phase <- atan(Im(Y)/Re(Y))
Yr <- Re(Y)
Yi <- Im(Y)
#PLOTTING
layout(matrix(c(1,2), 2, 1, byrow = TRUE))
plot(t,y,type=”l”,xlim=c(0,T))
plot(f[1:length(f)/2],mag[1:length(f)/2],type=”l”)
#PLOTTING
layout(matrix(c(1,2), 2, 1, byrow = TRUE))
plot(t,y,type="l",xlim=c(0,T))
plot(f[1:length(f)/2],mag[1:length(f)/2],type=”l”)
plot(f[1:length(f)/2],mag[1:length(f)/2],type="l")
#CREATE OUR TIME SERIES DATA
y <- [0.0198, 0.0373, 0.0, 0.0198, 0.0058, 0.1263, 0.005, 0.005, 0.0829, 0.005, 0.0373, 0.0946, 0.0198, 0.0198, 0.005, 0.0242, 0.0946, 0.0371, 0.1263, 0.0198, 0.0371, 0.0959, 0.0, 0.0516, 0.0829, 0.0371, 0.0036, 0.005, 0.005, 0.0946, 0.0946, 0.0, 0.0959, 0.0, 0.0242, 0.0198, 0.1263, 0.005, 0.0959, 0.0057, 0.1263, 0.005, 0.0057, 0.0959, 0.0058, 0.0371, 0.0829, 0.1263, 0.0198, 0.0242, 0.0, 0.0371, 0.0, 0.0761, 0.0, 0.0761, 0.0373, 0.0058, 0.0058, 0.0959, 0.005, 0.0548, 0.0829, 0.0, 0.0371, 0.005, 0.0057, 0.0829, 0.0373, 0.0036, 0.0959, 0.0516, 0.0, 0.0373, 0.0823, 0.0371, 0.0058, 0.1263, 0.005, 0.0959, 0.0, 0.0, 0.0373, 0.0829, 0.0371, 0.0829, 0.0057, 0.0941, 0.1263, 0.0058, 0.0829, 0.0946, 0.0946, 0.0946, 0.0058, 0.0959, 0.0, 0.0058, 0.0829, 0.0036, 0.0036, 0.0516, 0.0036, 0.0941, 0.0516, 0.0959, 0.0829, 0.0959, 0.0371, 0.0516, 0.0829, 0.0829, 0.0548, 0.0516, 0.0057, 0.0373, 0.0, 0.0371, 0.0959, 0.0941, 0.005, 0.0761, 0.0516, 0.0371, 0.0, 0.005, 0.0198, 0.0371, 0.0941, 0.005, 0.0198, 0.005, 0.0761, 0.0371, 0.0373, 0.0, 0.0, 0.0946, 0.0, 0.0198, 0.0823, 0.0829, 0.0373, 0.0371, 0.0829]
#CREATE OUR TIME SERIES DATA
y <- c(0.0198, 0.0373, 0.0, 0.0198, 0.0058, 0.1263, 0.005, 0.005, 0.0829, 0.005, 0.0373, 0.0946, 0.0198, 0.0198, 0.005, 0.0242, 0.0946, 0.0371, 0.1263, 0.0198, 0.0371, 0.0959, 0.0, 0.0516, 0.0829, 0.0371, 0.0036, 0.005, 0.005, 0.0946, 0.0946, 0.0, 0.0959, 0.0, 0.0242, 0.0198, 0.1263, 0.005, 0.0959, 0.0057, 0.1263, 0.005, 0.0057, 0.0959, 0.0058, 0.0371, 0.0829, 0.1263, 0.0198, 0.0242, 0.0, 0.0371, 0.0, 0.0761, 0.0, 0.0761, 0.0373, 0.0058, 0.0058, 0.0959, 0.005, 0.0548, 0.0829, 0.0, 0.0371, 0.005, 0.0057, 0.0829, 0.0373, 0.0036, 0.0959, 0.0516, 0.0, 0.0373, 0.0823, 0.0371, 0.0058, 0.1263, 0.005, 0.0959, 0.0, 0.0, 0.0373, 0.0829, 0.0371, 0.0829, 0.0057, 0.0941, 0.1263, 0.0058, 0.0829, 0.0946, 0.0946, 0.0946, 0.0058, 0.0959, 0.0, 0.0058, 0.0829, 0.0036, 0.0036, 0.0516, 0.0036, 0.0941, 0.0516, 0.0959, 0.0829, 0.0959, 0.0371, 0.0516, 0.0829, 0.0829, 0.0548, 0.0516, 0.0057, 0.0373, 0.0, 0.0371, 0.0959, 0.0941, 0.005, 0.0761, 0.0516, 0.0371, 0.0, 0.005, 0.0198, 0.0371, 0.0941, 0.005, 0.0198, 0.005, 0.0761, 0.0371, 0.0373, 0.0, 0.0, 0.0946, 0.0, 0.0198, 0.0823, 0.0829, 0.0373, 0.0371, 0.0829)
#CREATE OUR FREQUENCY ARRAY
f <- 1:length(t)/T
#Domain setup
T <- 1
dt <- 0.01 #s
n <- T/dt
F <-1/dt
df <- 1/T
freq<-5 #Hz
t <- seq(0,T,by=dt) #also try ts function
#CREATE OUR TIME SERIES DATA
y <- c(0.0198, 0.0373, 0.0, 0.0198, 0.0058, 0.1263, 0.005, 0.005, 0.0829, 0.005, 0.0373, 0.0946, 0.0198, 0.0198, 0.005, 0.0242, 0.0946, 0.0371, 0.1263, 0.0198, 0.0371, 0.0959, 0.0, 0.0516, 0.0829, 0.0371, 0.0036, 0.005, 0.005, 0.0946, 0.0946, 0.0, 0.0959, 0.0, 0.0242, 0.0198, 0.1263, 0.005, 0.0959, 0.0057, 0.1263, 0.005, 0.0057, 0.0959, 0.0058, 0.0371, 0.0829, 0.1263, 0.0198, 0.0242, 0.0, 0.0371, 0.0, 0.0761, 0.0, 0.0761, 0.0373, 0.0058, 0.0058, 0.0959, 0.005, 0.0548, 0.0829, 0.0, 0.0371, 0.005, 0.0057, 0.0829, 0.0373, 0.0036, 0.0959, 0.0516, 0.0, 0.0373, 0.0823, 0.0371, 0.0058, 0.1263, 0.005, 0.0959, 0.0, 0.0, 0.0373, 0.0829, 0.0371, 0.0829, 0.0057, 0.0941, 0.1263, 0.0058, 0.0829, 0.0946, 0.0946, 0.0946, 0.0058, 0.0959, 0.0, 0.0058, 0.0829, 0.0036, 0.0036, 0.0516, 0.0036, 0.0941, 0.0516, 0.0959, 0.0829, 0.0959, 0.0371, 0.0516, 0.0829, 0.0829, 0.0548, 0.0516, 0.0057, 0.0373, 0.0, 0.0371, 0.0959, 0.0941, 0.005, 0.0761, 0.0516, 0.0371, 0.0, 0.005, 0.0198, 0.0371, 0.0941, 0.005, 0.0198, 0.005, 0.0761, 0.0371, 0.0373, 0.0, 0.0, 0.0946, 0.0, 0.0198, 0.0823, 0.0829, 0.0373, 0.0371, 0.0829)
#CREATE OUR FREQUENCY ARRAY
f <- 1:length(t)/T
#FOURIER TRANSFORM WORK
Y <- fft(y)
mag <- sqrt(Re(Y)^2+Im(Y)^2)*2/n
phase <- atan(Im(Y)/Re(Y))
Yr <- Re(Y)
Yi <- Im(Y)
#PLOTTING
layout(matrix(c(1,2), 2, 1, byrow = TRUE))
plot(t,y,type="l",xlim=c(0,T))
#PLOTTING
layout(matrix(c(1,2), 2, 1, byrow = TRUE))
plot(t,y,type="l",xlim=c(0,T))
freq<-1 #Hz
t <- seq(0,T,by=dt) #also try ts function
require(stats)
#Domain setup
T <- 1
dt <- 0.01 #s
n <- T/dt
F <-1/dt
df <- 1/T
freq<-1 #Hz
t <- seq(0,T,by=dt) #also try ts function
#CREATE OUR TIME SERIES DATA
y <- c(0.0198, 0.0373, 0.0, 0.0198, 0.0058, 0.1263, 0.005, 0.005, 0.0829, 0.005, 0.0373, 0.0946, 0.0198, 0.0198, 0.005, 0.0242, 0.0946, 0.0371, 0.1263, 0.0198, 0.0371, 0.0959, 0.0, 0.0516, 0.0829, 0.0371, 0.0036, 0.005, 0.005, 0.0946, 0.0946, 0.0, 0.0959, 0.0, 0.0242, 0.0198, 0.1263, 0.005, 0.0959, 0.0057, 0.1263, 0.005, 0.0057, 0.0959, 0.0058, 0.0371, 0.0829, 0.1263, 0.0198, 0.0242, 0.0, 0.0371, 0.0, 0.0761, 0.0, 0.0761, 0.0373, 0.0058, 0.0058, 0.0959, 0.005, 0.0548, 0.0829, 0.0, 0.0371, 0.005, 0.0057, 0.0829, 0.0373, 0.0036, 0.0959, 0.0516, 0.0, 0.0373, 0.0823, 0.0371, 0.0058, 0.1263, 0.005, 0.0959, 0.0, 0.0, 0.0373, 0.0829, 0.0371, 0.0829, 0.0057, 0.0941, 0.1263, 0.0058, 0.0829, 0.0946, 0.0946, 0.0946, 0.0058, 0.0959, 0.0, 0.0058, 0.0829, 0.0036, 0.0036, 0.0516, 0.0036, 0.0941, 0.0516, 0.0959, 0.0829, 0.0959, 0.0371, 0.0516, 0.0829, 0.0829, 0.0548, 0.0516, 0.0057, 0.0373, 0.0, 0.0371, 0.0959, 0.0941, 0.005, 0.0761, 0.0516, 0.0371, 0.0, 0.005, 0.0198, 0.0371, 0.0941, 0.005, 0.0198, 0.005, 0.0761, 0.0371, 0.0373, 0.0, 0.0, 0.0946, 0.0, 0.0198, 0.0823, 0.0829, 0.0373, 0.0371, 0.0829)
#CREATE OUR FREQUENCY ARRAY
f <- 1:length(t)/T
#FOURIER TRANSFORM WORK
Y <- fft(y)
dt <- 1 #s
n <- T/dt
F <-1/dt
df <- 1/T
freq<-1 #Hz
t <- seq(0,T,by=dt) #also try ts function
#Domain setup
T <- 145
dt <- 1 #s
n <- T/dt
F <-1/dt
df <- 1/T
freq<-1 #Hz
t <- seq(0,T,by=dt) #also try ts function
#CREATE OUR TIME SERIES DATA
y <- c(0.0198, 0.0373, 0.0, 0.0198, 0.0058, 0.1263, 0.005, 0.005, 0.0829, 0.005, 0.0373, 0.0946, 0.0198, 0.0198, 0.005, 0.0242, 0.0946, 0.0371, 0.1263, 0.0198, 0.0371, 0.0959, 0.0, 0.0516, 0.0829, 0.0371, 0.0036, 0.005, 0.005, 0.0946, 0.0946, 0.0, 0.0959, 0.0, 0.0242, 0.0198, 0.1263, 0.005, 0.0959, 0.0057, 0.1263, 0.005, 0.0057, 0.0959, 0.0058, 0.0371, 0.0829, 0.1263, 0.0198, 0.0242, 0.0, 0.0371, 0.0, 0.0761, 0.0, 0.0761, 0.0373, 0.0058, 0.0058, 0.0959, 0.005, 0.0548, 0.0829, 0.0, 0.0371, 0.005, 0.0057, 0.0829, 0.0373, 0.0036, 0.0959, 0.0516, 0.0, 0.0373, 0.0823, 0.0371, 0.0058, 0.1263, 0.005, 0.0959, 0.0, 0.0, 0.0373, 0.0829, 0.0371, 0.0829, 0.0057, 0.0941, 0.1263, 0.0058, 0.0829, 0.0946, 0.0946, 0.0946, 0.0058, 0.0959, 0.0, 0.0058, 0.0829, 0.0036, 0.0036, 0.0516, 0.0036, 0.0941, 0.0516, 0.0959, 0.0829, 0.0959, 0.0371, 0.0516, 0.0829, 0.0829, 0.0548, 0.0516, 0.0057, 0.0373, 0.0, 0.0371, 0.0959, 0.0941, 0.005, 0.0761, 0.0516, 0.0371, 0.0, 0.005, 0.0198, 0.0371, 0.0941, 0.005, 0.0198, 0.005, 0.0761, 0.0371, 0.0373, 0.0, 0.0, 0.0946, 0.0, 0.0198, 0.0823, 0.0829, 0.0373, 0.0371, 0.0829)
#CREATE OUR FREQUENCY ARRAY
f <- 1:length(t)/T
#FOURIER TRANSFORM WORK
Y <- fft(y)
mag <- sqrt(Re(Y)^2+Im(Y)^2)*2/n
phase <- atan(Im(Y)/Re(Y))
Yr <- Re(Y)
Yi <- Im(Y)
#PLOTTING
layout(matrix(c(1,2), 2, 1, byrow = TRUE))
plot(t,y,type="l",xlim=c(0,T))
mag
teste <- seq(1,10)
mean(teste)
median(teste)
sum(teste)
sd(teste)
var(teste)
teste2 <- 2*(teste)
mean(teste2)
median(teste2)
sd(teste2)
var(teste2)
662.5/12/5
662.5/12.5
install.packages("BiocManager")
BiocManager::install("rSweep")
BiocManager::install("rSweeP")
BiocManager::install("rSWeeP")
library('rSWeeP')
ncRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/ncRNA.fasta'
library('rSWeeP')
mRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/mRNA.fasta'
ncRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/ncRNA.fasta'
?SWeePlite
sw <- SWeePlite(input = mRNA_seqs, psz = 1000, mask = (4), seqtype = 'NT')
seqs_path <- '/home/matheus/Downloads/apagar/FEELnc/seqs'
sw <- SWeePlite(input = seqs_path, psz = 1000, mask = (4), seqtype = 'NT')
sw$info
sw$proj
teste <- sw$proj
View(teste)
?`rSWeeP-package`
teste <- extractHDV(input = seqs_path, psz = 1000, mask = (4), seqtype = 'NT')
teste <- orthBase(col=1000, seqtype = 'NT', mask = (4))
View(teste)
sw <- SWeeP(input = seqs_path, psz = 1000, mask = (4), seqtype = 'NT')
orthbase <- orthBase(col=1000, seqtype = 'NT', mask = (4))
sw <- SWeeP(input = seqs_path, orthbase = orthbase, mask = (4), seqtype = 'NT')
View(sw)
? SWeePlite
sw <- SWeePlite(input = seqs_path, psz = 1000, mask = (4), seqtype = 'NT', concatenate = FALSE)
library('Biostrings')
Biostrings::BStringSet(mRNA_seqs)
teste <- Biostrings::BStringSet(mRNA_seqs)
View(teste)
teste
sw <- SWeePlite(input = teste, psz = 1000, mask = (4), seqtype = 'NT', concatenate = FALSE)
Biostrings::DNAStringSet(mRNA_seqs)
teste <- Biostrings::readBStringSet(mRNA_seqs)
mRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/seqs/mRNA.fasta'
ncRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/seqs/ncRNA.fasta'
teste <- Biostrings::readBStringSet(mRNA_seqs)
sw <- SWeePlite(input = teste, psz = 1000, mask = (4), seqtype = 'NT', concatenate = FALSE)
teste <- sw$proj
View(teste)
ncRNA <- Biostrings::readBStringSet(ncRNA_seqs)
sw_nc <- SWeePlite(input = ncRNA, psz = 1000, mask = (4), seqtype = 'NT', concatenate = FALSE, ncores = 8)
write.csv2('/home/matheus/Downloads/apagar/FEELnc/seqs/mRNA.csv')
? write.csv2
write.csv2(sw$proj, file = '/home/matheus/Downloads/apagar/FEELnc/seqs/mRNA.csv', sep = ';')
? write.csv
library('rSWeeP')
library('Biostrings')
mRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/seqs/mRNA.fasta'
ncRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/seqs/ncRNA.fasta'
mRNA <- Biostrings::readBStringSet(mRNA_seqs)
ncRNA <- Biostrings::readBStringSet(ncRNA_seqs)
sw_mrna <- SWeePlite(input = mRNA, psz = 1000, mask = c(5,5,5), seqtype = 'NT', concatenate = FALSE, ncores = 8)
sw_ncrna <- SWeePlite(input = ncRNA, psz = 1000, mask = (5,5,5), seqtype = 'NT', concatenate = FALSE, ncores = 8)
sw_ncrna <- SWeePlite(input = ncRNA, psz = 1000, mask = c(5,5,5), seqtype = 'NT', concatenate = FALSE, ncores = 8)
write.csv(sw_mrna$proj, file = '/home/matheus/Downloads/apagar/FEELnc/seqs/mRNA.csv', sep = ';')
write.csv(sw_ncrna$proj, file = '/home/matheus/Downloads/apagar/FEELnc/seqs/ncRNA.csv', sep = ';')
setwd("~/Documents/doc_tatiana/Git-Quali/")
options(scipen = 6, digits = 4) # For non-scientific notation
library("Biostrings") #Sequências
library("seqinr") # Sequências
library("igraph") # Grafo
library("dplyr") # Manipulação de dados
library("parallel") # Paralelização
source("createNet.R")
source("createAdjMatrix.R")
source("generateCombinations.R")
# Parametros
n_cores <- detectCores() - 1  # leave one core free
seq_name <- "HIV_6964.fasta" # arquivo .fasta com as sequências
seq <- readBStringSet(seq_name) # Leitura de sequências
seq_names <- names(seq) # Nome das sequências
lengths <- width(seq) # Tamanho das sequências
# Criar dataframe com informações das sequências
true_labels_hiv <- data.frame(name = seq_names, length = lengths, subtype = NA) # Completar a coluna com subtipo?
word <- 3
step <- 1
vertices_ordem <- c("AAA", "AAC", "AAG", "AAT", "ACA", "ACC", "ACG", "ACT", "AGA", "AGC", "AGG", "AGT", "ATA", "ATC", "ATG", "ATT",
"CAA", "CAC", "CAG", "CAT", "CCA", "CCC", "CCG", "CCT", "CGA", "CGC", "CGG", "CGT", "CTA", "CTC", "CTG", "CTT",
"GAA", "GAC", "GAG", "GAT", "GCA", "GCC", "GCG", "GCT", "GGA", "GGC", "GGG", "GGT", "GTA", "GTC", "GTG", "GTT",
"TAA", "TAC", "TAG", "TAT", "TCA", "TCC", "TCG", "TCT", "TGA", "TGC", "TGG", "TGT", "TTA", "TTC", "TTG", "TTT")
# Transformar sequências em matrizes de adjacência
char_seqs <- as.character(seq)
splitted_seq <- strsplit(char_seqs, split = "", fixed = TRUE)
adj_matrices <- mclapply(seq_along(splitted_seq), function(i) {
# sequence <- strsplit(toString(seq[i]), split = '', fixed = TRUE)[[1]]
createAdjMatrixFast(word, step, splitted_seq[i], vertices_ordem)
}, mc.cores = n_cores)
adj_matrices <- mclapply(seq_along(splitted_seq), function(i) {
# sequence <- strsplit(toString(seq[i]), split = '', fixed = TRUE)[[1]]
createAdjMatrixFast(word, step, splitted_seq[i], vertices_ordem)
}, mc.cores = n_cores)
adj_matrices <- mclapply(seq_along(splitted_seq), function(i) {
# sequence <- strsplit(toString(seq[i]), split = '', fixed = TRUE)[[1]]
createAdjMatrix(word, step, splitted_seq[i], vertices_ordem)
}, mc.cores = n_cores)
View(adj_matrices)
adj_matrices[[83]]
i<-1
sequence <- strsplit(toString(seq[i]), split = '', fixed = TRUE)[[1]]
splitted_seq[i]
sequence1<-splitted_seq[i]
sequence1[[1]]<-splitted_seq[i]
sequence1<-splitted_seq[i][[1]]
adj_matrices <- mclapply(seq_along(splitted_seq), function(i) {
# sequence <- strsplit(toString(seq[i]), split = '', fixed = TRUE)[[1]]
createAdjMatrix(word, step, splitted_seq[i][[1]], vertices_ordem)
}, mc.cores = n_cores)
seq_name<-"teste.fasta"
seq <- readBStringSet(seq_name) # Leitura de sequências
seq <- readBStringSet(seq_name) # Leitura de sequências
seq_names <- names(seq) # Nome das sequências
lengths <- width(seq) # Tamanho das sequências
# Criar dataframe com informações das sequências
true_labels_hiv <- data.frame(name = seq_names, length = lengths, subtype = NA) # Completar a coluna com subtipo?
word <- 3
step <- 1
vertices_ordem <- c("AAA", "AAC", "AAG", "AAT", "ACA", "ACC", "ACG", "ACT", "AGA", "AGC", "AGG", "AGT", "ATA", "ATC", "ATG", "ATT",
"CAA", "CAC", "CAG", "CAT", "CCA", "CCC", "CCG", "CCT", "CGA", "CGC", "CGG", "CGT", "CTA", "CTC", "CTG", "CTT",
"GAA", "GAC", "GAG", "GAT", "GCA", "GCC", "GCG", "GCT", "GGA", "GGC", "GGG", "GGT", "GTA", "GTC", "GTG", "GTT",
"TAA", "TAC", "TAG", "TAT", "TCA", "TCC", "TCG", "TCT", "TGA", "TGC", "TGG", "TGT", "TTA", "TTC", "TTG", "TTT")
# Transformar sequências em matrizes de adjacência
char_seqs <- as.character(seq)
splitted_seq <- strsplit(char_seqs, split = "", fixed = TRUE)
adj_matrices <- mclapply(seq_along(splitted_seq), function(i) {
# sequence <- strsplit(toString(seq[i]), split = '', fixed = TRUE)[[1]]
createAdjMatrix(word, step, splitted_seq[i][[1]], vertices_ordem)
}, mc.cores = n_cores)
View(adj_matrices)
# Adicionar nome as matrizes de adjacência
name_adj_matrices <- setNames(adj_matrices, true_labels_hiv$name)
# Transformar matrizes de adjacência em vetores
vectorized_matrices <- lapply(adj_matrices, function(x) as.vector(t(x)))
View(vectorized_matrices)
gc()
setwd("~/Documents/doc_tatiana/Git-Quali/")
options(scipen = 6, digits = 4) # For non-scientific notation
library("Biostrings") #Sequências
library("seqinr") # Sequências
library("igraph") # Grafo
library("dplyr") # Manipulação de dados
library("parallel") # Paralelização
source("createNet.R")
source("createAdjMatrix.R")
source("generateCombinations.R")
# Parametros
n_cores <- detectCores() - 1  # leave one core free
seq_name <- "HIV_6964.fasta" # arquivo .fasta com as sequências
seq <- readBStringSet(seq_name) # Leitura de sequências
seq_names <- names(seq) # Nome das sequências
lengths <- width(seq) # Tamanho das sequências
# Criar dataframe com informações das sequências
true_labels_hiv <- data.frame(name = seq_names, length = lengths, subtype = NA) # Completar a coluna com subtipo?
word <- 3
step <- 1
vertices_ordem <- c("AAA", "AAC", "AAG", "AAT", "ACA", "ACC", "ACG", "ACT", "AGA", "AGC", "AGG", "AGT", "ATA", "ATC", "ATG", "ATT",
"CAA", "CAC", "CAG", "CAT", "CCA", "CCC", "CCG", "CCT", "CGA", "CGC", "CGG", "CGT", "CTA", "CTC", "CTG", "CTT",
"GAA", "GAC", "GAG", "GAT", "GCA", "GCC", "GCG", "GCT", "GGA", "GGC", "GGG", "GGT", "GTA", "GTC", "GTG", "GTT",
"TAA", "TAC", "TAG", "TAT", "TCA", "TCC", "TCG", "TCT", "TGA", "TGC", "TGG", "TGT", "TTA", "TTC", "TTG", "TTT")
# Transformar sequências em matrizes de adjacência
char_seqs <- as.character(seq)
splitted_seq <- strsplit(char_seqs, split = "", fixed = TRUE)
adj_matrices <- mclapply(seq_along(splitted_seq), function(i) {
# sequence <- strsplit(toString(seq[i]), split = '', fixed = TRUE)[[1]]
createAdjMatrix(word, step, splitted_seq[i][[1]], vertices_ordem)
}, mc.cores = n_cores)
length(splitted_seq)
adj_matrices <- mclapply(seq_along(splitted_seq), function(i) {
# sequence <- strsplit(toString(seq[i]), split = '', fixed = TRUE)[[1]]
cat("Processing index:", i, "of", length(splitted_seq), "\n")
flush.console()
createAdjMatrix(word, step, splitted_seq[[i]], vertices_ordem)
}, mc.cores = n_cores)
#####################################################################################################################################
library(pbmcapply)
install.packages("pbmcapply")
#####################################################################################################################################
library(pbmcapply)
adj_matrices <- pbmclapply(seq_along(splitted_seq), function(i) {
# sequence <- strsplit(toString(seq[i]), split = '', fixed = TRUE)[[1]]
createAdjMatrix(word, step, splitted_seq[[i]], vertices_ordem)
}, mc.cores = n_cores)
# Adicionar nome as matrizes de adjacência
name_adj_matrices <- setNames(adj_matrices, true_labels_hiv$name)
# Transformar matrizes de adjacência em vetores
vectorized_matrices <- lapply(adj_matrices, function(x) as.vector(t(x)))
saveRDS(vectorized_matrices, file="vectorized_matrices.RData")
true_labels_hiv$subcluster[labels(cut(dend_euc, h = 700)$lower[[1]])] <- 1 #"C_1"
