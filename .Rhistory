layout(matrix(c(1,2), 2, 1, byrow = TRUE))
plot(t,y,type="l",xlim=c(0,T))
plot(f[1:length(f)/2],mag[1:length(f)/2],type=”l”)
plot(f[1:length(f)/2],mag[1:length(f)/2],type="l")
#CREATE OUR TIME SERIES DATA
y <- [0.0198, 0.0373, 0.0, 0.0198, 0.0058, 0.1263, 0.005, 0.005, 0.0829, 0.005, 0.0373, 0.0946, 0.0198, 0.0198, 0.005, 0.0242, 0.0946, 0.0371, 0.1263, 0.0198, 0.0371, 0.0959, 0.0, 0.0516, 0.0829, 0.0371, 0.0036, 0.005, 0.005, 0.0946, 0.0946, 0.0, 0.0959, 0.0, 0.0242, 0.0198, 0.1263, 0.005, 0.0959, 0.0057, 0.1263, 0.005, 0.0057, 0.0959, 0.0058, 0.0371, 0.0829, 0.1263, 0.0198, 0.0242, 0.0, 0.0371, 0.0, 0.0761, 0.0, 0.0761, 0.0373, 0.0058, 0.0058, 0.0959, 0.005, 0.0548, 0.0829, 0.0, 0.0371, 0.005, 0.0057, 0.0829, 0.0373, 0.0036, 0.0959, 0.0516, 0.0, 0.0373, 0.0823, 0.0371, 0.0058, 0.1263, 0.005, 0.0959, 0.0, 0.0, 0.0373, 0.0829, 0.0371, 0.0829, 0.0057, 0.0941, 0.1263, 0.0058, 0.0829, 0.0946, 0.0946, 0.0946, 0.0058, 0.0959, 0.0, 0.0058, 0.0829, 0.0036, 0.0036, 0.0516, 0.0036, 0.0941, 0.0516, 0.0959, 0.0829, 0.0959, 0.0371, 0.0516, 0.0829, 0.0829, 0.0548, 0.0516, 0.0057, 0.0373, 0.0, 0.0371, 0.0959, 0.0941, 0.005, 0.0761, 0.0516, 0.0371, 0.0, 0.005, 0.0198, 0.0371, 0.0941, 0.005, 0.0198, 0.005, 0.0761, 0.0371, 0.0373, 0.0, 0.0, 0.0946, 0.0, 0.0198, 0.0823, 0.0829, 0.0373, 0.0371, 0.0829]
#CREATE OUR TIME SERIES DATA
y <- c(0.0198, 0.0373, 0.0, 0.0198, 0.0058, 0.1263, 0.005, 0.005, 0.0829, 0.005, 0.0373, 0.0946, 0.0198, 0.0198, 0.005, 0.0242, 0.0946, 0.0371, 0.1263, 0.0198, 0.0371, 0.0959, 0.0, 0.0516, 0.0829, 0.0371, 0.0036, 0.005, 0.005, 0.0946, 0.0946, 0.0, 0.0959, 0.0, 0.0242, 0.0198, 0.1263, 0.005, 0.0959, 0.0057, 0.1263, 0.005, 0.0057, 0.0959, 0.0058, 0.0371, 0.0829, 0.1263, 0.0198, 0.0242, 0.0, 0.0371, 0.0, 0.0761, 0.0, 0.0761, 0.0373, 0.0058, 0.0058, 0.0959, 0.005, 0.0548, 0.0829, 0.0, 0.0371, 0.005, 0.0057, 0.0829, 0.0373, 0.0036, 0.0959, 0.0516, 0.0, 0.0373, 0.0823, 0.0371, 0.0058, 0.1263, 0.005, 0.0959, 0.0, 0.0, 0.0373, 0.0829, 0.0371, 0.0829, 0.0057, 0.0941, 0.1263, 0.0058, 0.0829, 0.0946, 0.0946, 0.0946, 0.0058, 0.0959, 0.0, 0.0058, 0.0829, 0.0036, 0.0036, 0.0516, 0.0036, 0.0941, 0.0516, 0.0959, 0.0829, 0.0959, 0.0371, 0.0516, 0.0829, 0.0829, 0.0548, 0.0516, 0.0057, 0.0373, 0.0, 0.0371, 0.0959, 0.0941, 0.005, 0.0761, 0.0516, 0.0371, 0.0, 0.005, 0.0198, 0.0371, 0.0941, 0.005, 0.0198, 0.005, 0.0761, 0.0371, 0.0373, 0.0, 0.0, 0.0946, 0.0, 0.0198, 0.0823, 0.0829, 0.0373, 0.0371, 0.0829)
#CREATE OUR FREQUENCY ARRAY
f <- 1:length(t)/T
#Domain setup
T <- 1
dt <- 0.01 #s
n <- T/dt
F <-1/dt
df <- 1/T
freq<-5 #Hz
t <- seq(0,T,by=dt) #also try ts function
#CREATE OUR TIME SERIES DATA
y <- c(0.0198, 0.0373, 0.0, 0.0198, 0.0058, 0.1263, 0.005, 0.005, 0.0829, 0.005, 0.0373, 0.0946, 0.0198, 0.0198, 0.005, 0.0242, 0.0946, 0.0371, 0.1263, 0.0198, 0.0371, 0.0959, 0.0, 0.0516, 0.0829, 0.0371, 0.0036, 0.005, 0.005, 0.0946, 0.0946, 0.0, 0.0959, 0.0, 0.0242, 0.0198, 0.1263, 0.005, 0.0959, 0.0057, 0.1263, 0.005, 0.0057, 0.0959, 0.0058, 0.0371, 0.0829, 0.1263, 0.0198, 0.0242, 0.0, 0.0371, 0.0, 0.0761, 0.0, 0.0761, 0.0373, 0.0058, 0.0058, 0.0959, 0.005, 0.0548, 0.0829, 0.0, 0.0371, 0.005, 0.0057, 0.0829, 0.0373, 0.0036, 0.0959, 0.0516, 0.0, 0.0373, 0.0823, 0.0371, 0.0058, 0.1263, 0.005, 0.0959, 0.0, 0.0, 0.0373, 0.0829, 0.0371, 0.0829, 0.0057, 0.0941, 0.1263, 0.0058, 0.0829, 0.0946, 0.0946, 0.0946, 0.0058, 0.0959, 0.0, 0.0058, 0.0829, 0.0036, 0.0036, 0.0516, 0.0036, 0.0941, 0.0516, 0.0959, 0.0829, 0.0959, 0.0371, 0.0516, 0.0829, 0.0829, 0.0548, 0.0516, 0.0057, 0.0373, 0.0, 0.0371, 0.0959, 0.0941, 0.005, 0.0761, 0.0516, 0.0371, 0.0, 0.005, 0.0198, 0.0371, 0.0941, 0.005, 0.0198, 0.005, 0.0761, 0.0371, 0.0373, 0.0, 0.0, 0.0946, 0.0, 0.0198, 0.0823, 0.0829, 0.0373, 0.0371, 0.0829)
#CREATE OUR FREQUENCY ARRAY
f <- 1:length(t)/T
#FOURIER TRANSFORM WORK
Y <- fft(y)
mag <- sqrt(Re(Y)^2+Im(Y)^2)*2/n
phase <- atan(Im(Y)/Re(Y))
Yr <- Re(Y)
Yi <- Im(Y)
#PLOTTING
layout(matrix(c(1,2), 2, 1, byrow = TRUE))
plot(t,y,type="l",xlim=c(0,T))
#PLOTTING
layout(matrix(c(1,2), 2, 1, byrow = TRUE))
plot(t,y,type="l",xlim=c(0,T))
freq<-1 #Hz
t <- seq(0,T,by=dt) #also try ts function
require(stats)
#Domain setup
T <- 1
dt <- 0.01 #s
n <- T/dt
F <-1/dt
df <- 1/T
freq<-1 #Hz
t <- seq(0,T,by=dt) #also try ts function
#CREATE OUR TIME SERIES DATA
y <- c(0.0198, 0.0373, 0.0, 0.0198, 0.0058, 0.1263, 0.005, 0.005, 0.0829, 0.005, 0.0373, 0.0946, 0.0198, 0.0198, 0.005, 0.0242, 0.0946, 0.0371, 0.1263, 0.0198, 0.0371, 0.0959, 0.0, 0.0516, 0.0829, 0.0371, 0.0036, 0.005, 0.005, 0.0946, 0.0946, 0.0, 0.0959, 0.0, 0.0242, 0.0198, 0.1263, 0.005, 0.0959, 0.0057, 0.1263, 0.005, 0.0057, 0.0959, 0.0058, 0.0371, 0.0829, 0.1263, 0.0198, 0.0242, 0.0, 0.0371, 0.0, 0.0761, 0.0, 0.0761, 0.0373, 0.0058, 0.0058, 0.0959, 0.005, 0.0548, 0.0829, 0.0, 0.0371, 0.005, 0.0057, 0.0829, 0.0373, 0.0036, 0.0959, 0.0516, 0.0, 0.0373, 0.0823, 0.0371, 0.0058, 0.1263, 0.005, 0.0959, 0.0, 0.0, 0.0373, 0.0829, 0.0371, 0.0829, 0.0057, 0.0941, 0.1263, 0.0058, 0.0829, 0.0946, 0.0946, 0.0946, 0.0058, 0.0959, 0.0, 0.0058, 0.0829, 0.0036, 0.0036, 0.0516, 0.0036, 0.0941, 0.0516, 0.0959, 0.0829, 0.0959, 0.0371, 0.0516, 0.0829, 0.0829, 0.0548, 0.0516, 0.0057, 0.0373, 0.0, 0.0371, 0.0959, 0.0941, 0.005, 0.0761, 0.0516, 0.0371, 0.0, 0.005, 0.0198, 0.0371, 0.0941, 0.005, 0.0198, 0.005, 0.0761, 0.0371, 0.0373, 0.0, 0.0, 0.0946, 0.0, 0.0198, 0.0823, 0.0829, 0.0373, 0.0371, 0.0829)
#CREATE OUR FREQUENCY ARRAY
f <- 1:length(t)/T
#FOURIER TRANSFORM WORK
Y <- fft(y)
dt <- 1 #s
n <- T/dt
F <-1/dt
df <- 1/T
freq<-1 #Hz
t <- seq(0,T,by=dt) #also try ts function
#Domain setup
T <- 145
dt <- 1 #s
n <- T/dt
F <-1/dt
df <- 1/T
freq<-1 #Hz
t <- seq(0,T,by=dt) #also try ts function
#CREATE OUR TIME SERIES DATA
y <- c(0.0198, 0.0373, 0.0, 0.0198, 0.0058, 0.1263, 0.005, 0.005, 0.0829, 0.005, 0.0373, 0.0946, 0.0198, 0.0198, 0.005, 0.0242, 0.0946, 0.0371, 0.1263, 0.0198, 0.0371, 0.0959, 0.0, 0.0516, 0.0829, 0.0371, 0.0036, 0.005, 0.005, 0.0946, 0.0946, 0.0, 0.0959, 0.0, 0.0242, 0.0198, 0.1263, 0.005, 0.0959, 0.0057, 0.1263, 0.005, 0.0057, 0.0959, 0.0058, 0.0371, 0.0829, 0.1263, 0.0198, 0.0242, 0.0, 0.0371, 0.0, 0.0761, 0.0, 0.0761, 0.0373, 0.0058, 0.0058, 0.0959, 0.005, 0.0548, 0.0829, 0.0, 0.0371, 0.005, 0.0057, 0.0829, 0.0373, 0.0036, 0.0959, 0.0516, 0.0, 0.0373, 0.0823, 0.0371, 0.0058, 0.1263, 0.005, 0.0959, 0.0, 0.0, 0.0373, 0.0829, 0.0371, 0.0829, 0.0057, 0.0941, 0.1263, 0.0058, 0.0829, 0.0946, 0.0946, 0.0946, 0.0058, 0.0959, 0.0, 0.0058, 0.0829, 0.0036, 0.0036, 0.0516, 0.0036, 0.0941, 0.0516, 0.0959, 0.0829, 0.0959, 0.0371, 0.0516, 0.0829, 0.0829, 0.0548, 0.0516, 0.0057, 0.0373, 0.0, 0.0371, 0.0959, 0.0941, 0.005, 0.0761, 0.0516, 0.0371, 0.0, 0.005, 0.0198, 0.0371, 0.0941, 0.005, 0.0198, 0.005, 0.0761, 0.0371, 0.0373, 0.0, 0.0, 0.0946, 0.0, 0.0198, 0.0823, 0.0829, 0.0373, 0.0371, 0.0829)
#CREATE OUR FREQUENCY ARRAY
f <- 1:length(t)/T
#FOURIER TRANSFORM WORK
Y <- fft(y)
mag <- sqrt(Re(Y)^2+Im(Y)^2)*2/n
phase <- atan(Im(Y)/Re(Y))
Yr <- Re(Y)
Yi <- Im(Y)
#PLOTTING
layout(matrix(c(1,2), 2, 1, byrow = TRUE))
plot(t,y,type="l",xlim=c(0,T))
mag
teste <- seq(1,10)
mean(teste)
median(teste)
sum(teste)
sd(teste)
var(teste)
teste2 <- 2*(teste)
mean(teste2)
median(teste2)
sd(teste2)
var(teste2)
662.5/12/5
662.5/12.5
install.packages("BiocManager")
BiocManager::install("rSweep")
BiocManager::install("rSweeP")
BiocManager::install("rSWeeP")
library('rSWeeP')
ncRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/ncRNA.fasta'
library('rSWeeP')
mRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/mRNA.fasta'
ncRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/ncRNA.fasta'
?SWeePlite
sw <- SWeePlite(input = mRNA_seqs, psz = 1000, mask = (4), seqtype = 'NT')
seqs_path <- '/home/matheus/Downloads/apagar/FEELnc/seqs'
sw <- SWeePlite(input = seqs_path, psz = 1000, mask = (4), seqtype = 'NT')
sw$info
sw$proj
teste <- sw$proj
View(teste)
?`rSWeeP-package`
teste <- extractHDV(input = seqs_path, psz = 1000, mask = (4), seqtype = 'NT')
teste <- orthBase(col=1000, seqtype = 'NT', mask = (4))
View(teste)
sw <- SWeeP(input = seqs_path, psz = 1000, mask = (4), seqtype = 'NT')
orthbase <- orthBase(col=1000, seqtype = 'NT', mask = (4))
sw <- SWeeP(input = seqs_path, orthbase = orthbase, mask = (4), seqtype = 'NT')
View(sw)
? SWeePlite
sw <- SWeePlite(input = seqs_path, psz = 1000, mask = (4), seqtype = 'NT', concatenate = FALSE)
library('Biostrings')
Biostrings::BStringSet(mRNA_seqs)
teste <- Biostrings::BStringSet(mRNA_seqs)
View(teste)
teste
sw <- SWeePlite(input = teste, psz = 1000, mask = (4), seqtype = 'NT', concatenate = FALSE)
Biostrings::DNAStringSet(mRNA_seqs)
teste <- Biostrings::readBStringSet(mRNA_seqs)
mRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/seqs/mRNA.fasta'
ncRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/seqs/ncRNA.fasta'
teste <- Biostrings::readBStringSet(mRNA_seqs)
sw <- SWeePlite(input = teste, psz = 1000, mask = (4), seqtype = 'NT', concatenate = FALSE)
teste <- sw$proj
View(teste)
ncRNA <- Biostrings::readBStringSet(ncRNA_seqs)
sw_nc <- SWeePlite(input = ncRNA, psz = 1000, mask = (4), seqtype = 'NT', concatenate = FALSE, ncores = 8)
write.csv2('/home/matheus/Downloads/apagar/FEELnc/seqs/mRNA.csv')
? write.csv2
write.csv2(sw$proj, file = '/home/matheus/Downloads/apagar/FEELnc/seqs/mRNA.csv', sep = ';')
? write.csv
library('rSWeeP')
library('Biostrings')
mRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/seqs/mRNA.fasta'
ncRNA_seqs <- '/home/matheus/Downloads/apagar/FEELnc/seqs/ncRNA.fasta'
mRNA <- Biostrings::readBStringSet(mRNA_seqs)
ncRNA <- Biostrings::readBStringSet(ncRNA_seqs)
sw_mrna <- SWeePlite(input = mRNA, psz = 1000, mask = c(5,5,5), seqtype = 'NT', concatenate = FALSE, ncores = 8)
sw_ncrna <- SWeePlite(input = ncRNA, psz = 1000, mask = (5,5,5), seqtype = 'NT', concatenate = FALSE, ncores = 8)
sw_ncrna <- SWeePlite(input = ncRNA, psz = 1000, mask = c(5,5,5), seqtype = 'NT', concatenate = FALSE, ncores = 8)
write.csv(sw_mrna$proj, file = '/home/matheus/Downloads/apagar/FEELnc/seqs/mRNA.csv', sep = ';')
write.csv(sw_ncrna$proj, file = '/home/matheus/Downloads/apagar/FEELnc/seqs/ncRNA.csv', sep = ';')
setwd("~/Documents/doc_tatiana/Git-Quali/")
options(scipen = 6, digits = 4) # For non-scientific notation
library("Biostrings") #Sequências
library("seqinr") # Sequências
library("igraph") # Grafo
library("dplyr") # Manipulação de dados
library("pbmcapply") # Paralelização (com progress bar)
source("createNet.R")
source("createAdjMatrix.R")
source("generateCombinations.R")
# Parametros
n_cores <- detectCores() - 1  # leave one core free
seq_name <- "HIV_6964.fasta" # arquivo .fasta com as sequências
seq <- readBStringSet(seq_name) # Leitura de sequências
seq_names <- names(seq) # Nome das sequências
lengths <- width(seq) # Tamanho das sequências
# Criar dataframe com informações das sequências
true_labels_hiv <- data.frame(name = seq_names, length = lengths, subtype = NA) # Completar a coluna com subtipo?
# Caso já tenha o arquivo pronto
true_labels_hiv <- read.csv("HIV_6946annota.csv", header = TRUE, sep = ";") # arquivo com informações das seq. - name, subtype, length
word <- 3
step <- 1
vertices_ordem <- c("AAA", "AAC", "AAG", "AAT", "ACA", "ACC", "ACG", "ACT", "AGA", "AGC", "AGG", "AGT", "ATA", "ATC", "ATG", "ATT",
"CAA", "CAC", "CAG", "CAT", "CCA", "CCC", "CCG", "CCT", "CGA", "CGC", "CGG", "CGT", "CTA", "CTC", "CTG", "CTT",
"GAA", "GAC", "GAG", "GAT", "GCA", "GCC", "GCG", "GCT", "GGA", "GGC", "GGG", "GGT", "GTA", "GTC", "GTG", "GTT",
"TAA", "TAC", "TAG", "TAT", "TCA", "TCC", "TCG", "TCT", "TGA", "TGC", "TGG", "TGT", "TTA", "TTC", "TTG", "TTT")
# Transformar sequências em matrizes de adjacência
char_seqs <- as.character(seq)
splitted_seq <- strsplit(char_seqs, split = "", fixed = TRUE)
adj_matrices <- pbmclapply(seq_along(splitted_seq), function(i) {
# sequence <- strsplit(toString(seq[i]), split = '', fixed = TRUE)[[1]]
createAdjMatrix(word, step, splitted_seq[[i]], vertices_ordem)
}, mc.cores = n_cores)
# Adicionar nome as matrizes de adjacência
name_adj_matrices <- setNames(adj_matrices, true_labels_hiv$name)
# Transformar matrizes de adjacência em vetores
vectorized_matrices <- lapply(adj_matrices, function(x) as.vector(t(x)))
setwd("~/Documents/doc_tatiana/Git-Quali/")
options(scipen = 6, digits = 4) # For non-scientific notation
library("dendextend") # Dendrogramas
library("stats") # Explícito para dist
## ---------------------------
##### Gerando matriz de distância
data_matrix <- do.call(rbind, vectorized_matrices)
dist_matriz_euclidean <- as.matrix(dist(data_matrix,
method = "euclidean"))
hc_euclidean <- hclust(as.dist(dist_matriz_euclidean),
method = "ward.D2")
dend_euc <- as.dendrogram(hc_euclidean)
leaf_order_euc <- order.dendrogram(dend_euc)
species_ordered_euc <- true_labels_hiv$subtype[leaf_order_euc]
unique_subtypes <- unique(true_labels_hiv$subtype)
colors <- rainbow(length(unique_subtypes))  # Gera 8 cores diferentes
species_colors_euc <- colors[as.numeric(factor(species_ordered_euc,
levels = unique_subtypes))]
dend_euc <- dend_euc %>% set("labels_colors",
species_colors_euc)
plot(dend_euc)
legend("topright", legend = unique_subtypes,
col = colors,
pch = 15,
title = "Subtipos")
#'
#' This function automatically finds appropriate cutting heights based on
#' changes in cluster structure and then validates clusters by homogeneity
#'
#' @param dend A dendrogram object
#' @param data The original data used to create the dendrogram
#' @param n_heights Number of height levels to examine
#' @param homogeneity_threshold Maximum within-cluster variance allowed
#' @param min_cluster_size Minimum cluster size
#' @return A data frame with optimized cluster assignments
adaptive_height_clustering <- function(dend, data, n_heights = 20,
homogeneity_threshold = 0.3,
min_cluster_size = 5) {
# Get height range of dendrogram
dend_heights <- heights_per_k.dendrogram(dend)
max_height <- max(dend_heights)
min_height <- min(dend_heights[dend_heights > 0])
# Generate sequence of heights to examine
# Use logarithmic scale to focus more on lower heights
heights <- exp(seq(log(max_height), log(min_height), length.out = n_heights))
# Store cluster counts at each height
cluster_counts <- numeric(length(heights))
# Calculate number of clusters at each height
for (i in 1:length(heights)) {
cut_result <- cut(dend, h = heights[i])
if (!is.null(cut_result$lower)) {
cluster_counts[i] <- length(cut_result$lower)
} else {
cluster_counts[i] <- 1
}
}
# Calculate rate of change in cluster count
cluster_change_rate <- c(0, diff(cluster_counts))
# Identify heights with significant changes in cluster structure
# These are good candidates for cutting points
significant_heights <- heights[which(cluster_change_rate > mean(cluster_change_rate))]
# If we didn't find significant heights, use a few spread across the range
if (length(significant_heights) == 0) {
significant_heights <- quantile(heights, probs = seq(0, 1, length.out = 5))
}
# Add some additional heights near the significant ones to refine clusters
refined_heights <- sort(c(significant_heights,
significant_heights * 0.8,
significant_heights * 1.2))
refined_heights <- refined_heights[refined_heights <= max_height &
refined_heights >= min_height]
# Get all labels
all_labels <- labels(dend)
# Create result dataframe
result_df <- data.frame(
label = all_labels,
subcluster = NA,
stringsAsFactors = FALSE
)
# Function to validate cluster homogeneity
validate_cluster <- function(cluster_labels) {
if (length(cluster_labels) < min_cluster_size) return(FALSE)
if (all(cluster_labels %in% rownames(data))) {
cluster_data <- data[cluster_labels, ]
# Calculate variance within cluster
cluster_center <- colMeans(cluster_data)
distances <- apply(cluster_data, 1, function(row) {
sqrt(sum((row - cluster_center)^2))
})
homogeneity <- mean(distances) / sqrt(ncol(cluster_data))
# Return TRUE if homogeneous enough
return(homogeneity <= homogeneity_threshold)
}
return(FALSE)
}
# Track assigned elements
assigned <- rep(FALSE, length(all_labels))
# Next cluster ID
next_cluster_id <- 1
# Process each height
for (h in sort(refined_heights, decreasing = TRUE)) {
cut_result <- cut(dend, h = h)
if (!is.null(cut_result$lower)) {
for (i in 1:length(cut_result$lower)) {
branch_labels <- labels(cut_result$lower[[i]])
# Skip if all elements already assigned
if (all(assigned[match(branch_labels, all_labels)])) {
next
}
# Validate the cluster
if (validate_cluster(branch_labels)) {
# Get indices of unassigned elements in this branch
branch_indices <- match(branch_labels, all_labels)
unassigned_indices <- branch_indices[!assigned[branch_indices]]
# Assign cluster ID
result_df$subcluster[unassigned_indices] <- next_cluster_id
# Mark as assigned
assigned[unassigned_indices] <- TRUE
# Increment cluster counter
next_cluster_id <- next_cluster_id + 1
}
}
}
}
# Assign any remaining unassigned elements
remaining_unassigned <- which(!assigned)
if (length(remaining_unassigned) > 0) {
# For remaining elements, try to assign them to nearest existing cluster
# or create new small clusters
# If we can, group remaining points into small clusters
if (length(remaining_unassigned) >= min_cluster_size) {
# Use a lower height to find smaller clusters
small_heights <- min_height * c(0.8, 0.6, 0.4, 0.2)
for (h in small_heights) {
if (all(assigned)) break
cut_result <- cut(dend, h = h)
if (!is.null(cut_result$lower)) {
for (i in 1:length(cut_result$lower)) {
branch_labels <- labels(cut_result$lower[[i]])
branch_indices <- match(branch_labels, all_labels)
# Only consider branches that contain unassigned elements
if (any(!assigned[branch_indices])) {
unassigned_in_branch <- branch_indices[!assigned[branch_indices]]
if (length(unassigned_in_branch) >= min_cluster_size) {
# Assign to new cluster
result_df$subcluster[unassigned_in_branch] <- next_cluster_id
assigned[unassigned_in_branch] <- TRUE
next_cluster_id <- next_cluster_id + 1
}
}
}
}
}
}
# Assign any remaining single points to their own clusters
still_unassigned <- which(!assigned)
for (i in still_unassigned) {
result_df$subcluster[i] <- next_cluster_id
next_cluster_id <- next_cluster_id + 1
}
}
return(list(
clusters_df = result_df,
significant_heights = significant_heights
))
}
# Visualize the clustering results
plot_dendrogram_clusters <- function(dend, clusters_df) {
# Color the dendrogram by clusters
dend_colored <- color_branches(dend, clusters = clusters_df$subcluster)
# Plot dendrogram
par(mar = c(5, 5, 2, 10))  # Adjust margins
plot(dend_colored, main = "Dendrogram with Optimized Subclusters",
xlab = "", sub = "", horiz = TRUE)
# Add legend for clusters (if not too many)
if (length(unique(clusters_df$subcluster)) <= 20) {
cluster_cols <- unique(get_leaves_branches_col(dend_colored))
cluster_ids <- unique(clusters_df$subcluster)
legend("topright", legend = paste("Cluster", cluster_ids),
fill = cluster_cols[1:length(cluster_ids)],
inset = c(-0.3, 0), xpd = TRUE)
}
}
original_data <- dist_matriz_euclidean
# Method 3: Adaptive height clustering
result3 <- adaptive_height_clustering(dend_euc, original_data,
n_heights = 20,
homogeneity_threshold = 0.9,
min_cluster_size = 10)
# For example, using results from method 3
true_labels_hiv <- read.csv("HIV_6946annota.csv", header = TRUE, sep = ";") # arquivo com informações das seq. - name, subtype, length
true_labels_hiv3 <- merge(true_labels_hiv, result3, by.x = "row_names", by.y = "label", all.x = TRUE)
# Caso já tenha o arquivo pronto
true_labels_hiv <- read.csv("HIV_6946annota.csv", header = TRUE, sep = ";") # arquivo com informações das seq. - name, subtype, length
true_labels_hiv3 <- merge(true_labels_hiv, result3, by.x = "row_names", by.y = "label", all.x = TRUE)
plot_dendrogram_clusters(dend_euc, result3)  # or use results from other methods
# Method 3: Adaptive height clustering
result3 <- adaptive_height_clustering(dend_euc, original_data,
n_heights = 20,
homogeneity_threshold = 0.1,
min_cluster_size = 10)
plot_dendrogram_clusters(dend_euc, result3)  # or use results from other methods
# Method 1: Dynamic clustering
result1 <- dynamic_subclustering(dend_euc, original_data,
max_height = 700,
homogeneity_threshold = 0.1,
density_threshold = 0.05,
min_cluster_size = 10)
plot_dendrogram_clusters(dend_euc, result1)  # or use results from other methods
#' This function automatically identifies subclusters in a dendrogram based on
#' homogeneity and density thresholds.
#'
#' @param dend A dendrogram object
#' @param data The original data used to create the dendrogram
#' @param max_height Maximum height to consider for initial cuts
#' @param homogeneity_threshold Maximum within-cluster variance allowed
#' @param density_threshold Minimum density required for a valid cluster
#' @param min_cluster_size Minimum number of elements required for a valid cluster
#' @return A data frame with cluster assignments
dynamic_subclustering <- function(dend, data, max_height = 700,
homogeneity_threshold = 0.3,
density_threshold = 0.05,
min_cluster_size = 5) {
# Get all labels from the dendrogram
all_labels <- labels(dend)
# Create a dataframe to store subcluster assignments
result_df <- data.frame(
label = all_labels,
subcluster = NA,
stringsAsFactors = FALSE
)
# Function to calculate within-cluster homogeneity
calculate_homogeneity <- function(cluster_data) {
if (nrow(cluster_data) <= 1) return(0)
# Use average distance to centroid as homogeneity measure
# Lower values indicate higher homogeneity
cluster_center <- colMeans(cluster_data)
distances <- apply(cluster_data, 1, function(row) {
sqrt(sum((row - cluster_center)^2))
})
return(mean(distances) / sqrt(ncol(cluster_data)))
}
# Function to calculate cluster density
calculate_density <- function(cluster_data) {
if (nrow(cluster_data) <= 1) return(0)
# Use average pairwise distance as density measure
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(cluster_data))
# Get average distance
avg_dist <- sum(dist_matrix) / (nrow(cluster_data) * (nrow(cluster_data) - 1))
# Invert so higher values mean higher density
return(1 / (1 + avg_dist))
}
# Cut dendrogram at multiple heights
heights <- seq(max_height, 30, by = -30)  # Adjust step as needed
# Track already assigned elements
assigned <- rep(FALSE, length(all_labels))
# Counter for subcluster IDs
next_cluster_id <- 1
# Process each height level
for (h in heights) {
# Cut the dendrogram at current height
cut_result <- cut(dend, h = h)
# Check each resulting cluster
if (!is.null(cut_result$lower)) {
for (i in 1:length(cut_result$lower)) {
branch_labels <- labels(cut_result$lower[[i]])
# Skip if all elements already assigned
if (all(assigned[match(branch_labels, all_labels)])) {
next
}
# Get indices of elements in this branch
branch_indices <- match(branch_labels, all_labels)
# Get data for this branch
if (all(branch_labels %in% rownames(data))) {
branch_data <- data[branch_labels, ]
# Skip clusters that are too small
if (length(branch_labels) < min_cluster_size) {
next
}
# Check homogeneity
homogeneity <- calculate_homogeneity(branch_data)
# Check density
density <- calculate_density(branch_data)
# If both criteria are met and not already assigned, assign to a new cluster
if (homogeneity <= homogeneity_threshold &&
density >= density_threshold &&
!all(assigned[branch_indices])) {
# Only assign elements that haven't been assigned yet
unassigned_indices <- branch_indices[!assigned[branch_indices]]
# Assign cluster ID to unassigned elements
result_df$subcluster[unassigned_indices] <- next_cluster_id
# Mark as assigned
assigned[unassigned_indices] <- TRUE
# Increment cluster counter
next_cluster_id <- next_cluster_id + 1
}
}
}
}
}
# Assign any remaining unassigned elements to their own clusters
remaining_unassigned <- which(!assigned)
for (i in remaining_unassigned) {
result_df$subcluster[i] <- next_cluster_id
next_cluster_id <- next_cluster_id + 1
}
return(result_df)
}
# Method 1: Dynamic clustering
result1 <- dynamic_subclustering(dend_euc, original_data,
max_height = 700,
homogeneity_threshold = 0.1,
density_threshold = 0.05,
min_cluster_size = 10)
plot_dendrogram_clusters(dend_euc, result1)  # or use results from other methods
setwd("~/Documents/doc_tatiana/Git-Quali/")
options(scipen = 6, digits = 4) # For non-scientific notation
library("dendextend")
library("ggplot2")
library("dplyr")
library("cluster")
source("dynamic_subclustering.R")
source("adaptive_height_clustering.R")
source("plot_dendrogram_clusters.R")
